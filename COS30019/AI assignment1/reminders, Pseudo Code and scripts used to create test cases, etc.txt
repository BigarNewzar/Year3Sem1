


//it works now! needed to put as .net framework file, not .net core

//need to check whether it works standalone or if it still needs that pb file thing

//also clean up stuff---agent and UI comment cleanup still left


//mention that the fact that you coded in .core for all this time and it didnt wokr at all when you tried to publish it and then you tried with .net framework following info from "stack overflow" and it worked instantly


++Need to setup the input method as well

+++Wanted to try depth limited--but am confused--should i limit on number entering node? or should i limit on how far it can go?

++do research on it

+++Planning on doing research on depth limited aspect--ie how far should agent go in terms of depth depending on map? depending on wall? depedning on non wall cell? depending on start to goal state? etc.

+++PLanning on doing research on this. How many data point should i take for each case? 100 different maps? 1000 different maps?---100 is ok

++Put internal customer timer inside the search parts ++ use that as calculation

path length


test cases Map generation


intital = i
goal = g
wall = w


width and height

i, g and w cant exceed width and height
i cant be w
g cant be w






intial = goal
i






Execution time for various grid shapes

Number of node traversed

Memory used to run search

var watch = new System.Diagnostics.Stopwatch();
            
watch.Start();


watch.Stop();

Console.WriteLine($"Execution Time: {watch.ElapsedMilliseconds} ms");








+ See what we need to do in assignment 2 in INF20028


+ see what we need to do in SRS


+ finish AI Code brushing up and put it as clean, single exe file
+ make the report for that

+ finish the lab report for week 6 (full proper report format and words)

study AI all week lect and lab tute _ practise exam --Saturday and Sunday


Study TNE all week lect and lab and tute ---Monday and Tuesday

=AVERAGE(A2:A117)

=AVERAGE(A2:A100)...20 so make it 100

bfs,dfs,dfslim,astar, gbfs, astarlim


Get Optimal path data and add to excel sheets

//Script to run the comamdn with only the filenames for bfs




get-childitem Map*.txt | foreach-object{.\search.exe $_.BaseName dfs}

get-childitem Map*.txt | foreach-object{.\search.exe $_.BaseName dfslim}


get-childitem Map*.txt | foreach-object{.\search.exe $_.BaseName bfs}

++ Clean Up code parts!-- comment all the test parts and rebuild solution after testing is done


+ Update the TOCs after finishing

Wait until 11:30AM and then send this

Dear Shruthi,

Hope you are doing well.

People from the pest control have gone through the room beside mine (room 311) an hour or so ago (10:00AM) and yet have not gone through mine (room 310) even now. So I was wondering if everything was alright?

Furthermore, I will have to leave for work soon and thus I was wondering if they would take even more time? If so I believe it would be better to go through my room and perform pest controll another day as I wouldn't be here from 12:01PM onwords.



get-childitem Map*.txt | foreach-object{.\search.exe $_.BaseName gbfs}


get-childitem Map*.txt | foreach-object{.\search.exe $_.BaseName astar}

get-childitem Map*.txt | foreach-object{.\search.exe $_.BaseName astarlim}




=AVERAGE(A2:A117)








get-childitem Map*.txt | foreach-object{echo $_.BaseName}


.\search.exe testMap bfs
.\search.exe testMap dfs


.\search.exe testMap dfslim
.\search.exe testMap gbfs
.\search.exe testMap astar
.\search.exe testMap astarlim



//10,000 ticks ==1 ms
            //ref: https://learn.microsoft.com/en-us/dotnet/api/system.datetime.ticks?view=net-7.0
            string watchTicks = watch.ElapsedTicks.ToString();
            Console.WriteLine("Execution Time for the search function:" + watchTicks + "ticks");


            //gets me the number of bytes currently thought to be allocated
            long totalMemoryUsed = GC.GetTotalMemory(true);
            Console.WriteLine(totalMemoryUsed);
            Console.WriteLine("Press Enter after noting down the time and matric");
            Console.ReadLine();

            string myfile = "TestdataForAlgo.txt";

            //"D:\\visual stuido 2022 repo\\AI assignment 1\\AI_Assignment_V3\\ConsoleApp1\\bin\\Release"

            // Appending the given texts
            using (StreamWriter sw = File.AppendText(myfile))
            {

                sw.WriteLine(watchTicks + "," + totalMemoryUsed + "," + ai.getVisited.Count);



            }
			
			
			Also used  
			
			var watch = new System.Diagnostics.Stopwatch();

            watch.Start();
			
			inside the chooseSearch function
			
			
			also:
			 GC.Collect ---to force run the garbage collector to ensure previous running of code didnt have any impact on the next running of the code
			 
			 
			 
In code:

/// <summary>
        /// The search algo for depth first search
        /// </summary>
        /// <returns>current position if at goal, no solution if no goal, solution path if goal is found</returns>
		
		
		
//See the output in verbose and graphical manner

					
//Make sure the room is within the _map
                        
//Make sure there is linked paths
                            
 //Make sure no repeated state
                                
									
//Push adjacent nodes to the _frontier

//If algo can find the solution

//If algo can't find the solution
               
	/// <summary>
        /// Draw process of expanding node for ones using Stack to store frontier nodes
        /// </summary>
        /// <param name="initial">Agent position</param>
        /// <param name="goal">Goal position</param>
        /// <param name="wall">Wall position</param>
        /// <param name="visitedNode">Node that is currently being visited</param>
        /// <param name="mapWidth">Max width of map</param>
        /// <param name="mapLength">Max length of map</param>
        /// <param name="frontier">Nodes that are currently in frontier</param>		   
			   
			   
 //Set position of Agent
 
 //Set position of goal
                    

//Set position of the visitedNode
                    

//Set position of wall
                    
//Set empty cells

//Output of where goal was found
            
//Outputting nodes that are in the frontier 
            
//Outputting node that is currently being visited

if (path.Any(x => x.X == j && x.Y == i))
                    {
                        Console.Write("|x");
                        continue;
                    }
					
					
DfsSearch()					
IF (intial position's X and Y = goal position's X and Y) THEN
Return that the solution is here and no need to move
ELSE
make frontier as a Stack
make visited as a List
make visitedNode as a point2D
Push current position node to frontier
	WHILE (anything is still in frontier)
	visitedNode <- POP the node from frontier
	ADD visitedNode to visited 
	DRAW it using ui
		FOREACH(room r in map.room)
			IF(Visited node's X and Y = r's position's X and Y ) THEN
				IF(r has a path) THEN
					FOREACH(path p in r.path)
						IF(X and Y position noted in any of the nodes, in either visited or frontier, doesn't matches with that stated on the adjacent room attached on the other end of the p) THEN						
						ParentNode for the room located on the other side of the p <- visitedNode						
						PUSH the room located on the other side of path into the frontier						
						ENDIF
					ENDFOR				
				ENDIF				
				IF(visited node's X and Y = goal node's X and Y) THEN
				Return that solveIT method needs to be run with the necessary parameters				
				ENDIF				
			ENDIF		
		ENDFOR
	ENDWHILE	
	Return that No solution
ENDIF








DfsLimitedSearch()	
maxdepth <- map's length * height /2
depth <- max depth				
IF (intial position's X and Y = goal position's X and Y and depth greater than 0) THEN
Return that the solution is here and no need to move
ELSE
make frontier as a Stack
make visited as a List
make visitedNode as a point2D
Push current position node to frontier
	WHILE (anything is still in frontier and depth is greater than 0)
	visitedNode <- POP the node from frontier
	ADD visitedNode to visited 
	DRAW it using ui
	depth <- depth - 1
		FOREACH(room r in map.room)
			IF(Visited node's X and Y = r's position's X and Y ) THEN
				IF(r has a path) THEN
					FOREACH(path p in r.path)
						IF(X and Y position noted in any of the nodes, in either visited or frontier, doesn't matches with that stated on the adjacent room attached on the other end of the p)	THEN					
						ParentNode for the room located on the other side of the p <- visitedNode						
						PUSH the room located on the other side of path into the frontier						
						ENDIF
					ENDFOR				
				ENDIF				
				IF(visited node's X and Y = goal node's X and Y and depth greater than 0) THEN
				Return that solveIT method needs to be run with the necessary parameters				
				ENDIF				
			ENDIF		
		ENDFOR
	ENDWHILE	
	Return that No solution at given max depth
ENDIF



BfsSearch()					
IF (intial position's X and Y = goal position's X and Y) THEN
Return that the solution is here and no need to move
ELSE
make frontier as a Queue
make visited as a List
make visitedNode as a point2D
ENQUEUE current position node to frontier
	WHILE (anything is still in frontier)
	visitedNode <- DEQUEUE the node from frontier
	ADD visitedNode to visited 
	DRAW it using ui
		FOREACH(room r in map.room)
			IF(Visited node's X and Y = r's position's X and Y ) THEN
				IF(r has a path) THEN
					FOREACH(path p in r.path)
						IF(X and Y position noted in any of the nodes, in either visited or frontier, doesn't matches with that stated on the adjacent room attached on the other end of the p)	THEN					
						ParentNode for the room located on the other side of the p <- visitedNode						
						ENQUEUE the room located on the other side of path into the frontier						
						ENDIF
					ENDFOR				
				ENDIF				
				IF(visited node's X and Y = goal node's X and Y) THEN
				Return that solveIT method needs to be run with the necessary parameters				
				ENDIF				
			ENDIF		
		ENDFOR
	ENDWHILE	
	Return that No solution
ENDIF





GbfsSearch()					
IF (intial position's X and Y = goal position's X and Y) THEN
Return that the solution is here and no need to move
ELSE
make frontier as a List
make visited as a List
make visitedNode as a point2D
ADD current position node to frontier
	WHILE (anything is still in frontier)
	frontier <- ORDER elements in frontier BY Hscore and convert output TO LIST
	visitedNode <- FIRST element in frontier
	REMOVE the FIRST element from frontier	
	ADD visitedNode to visited 
	DRAW it using ui
		FOREACH(room r in map.room)
			IF(Visited node's X and Y = r's position's X and Y ) THEN
				IF(r has a path) THEN
					FOREACH(path p in r.path)
						IF(X and Y position noted in any of the nodes, in either visited or frontier, doesn't matches with that stated on the adjacent room attached on the other end of the p) THEN						
						ParentNode for the room located on the other side of the p <- visitedNode	
						Hscore for the room located on the other side of the p <- squareroot of(sum of (square of difference between X value of room located on the other side of the p and goal) and (square of difference between Y value of room located on the other side of the p and goal))
						ADD the room located on the other side of path into the frontier						
						ENDIF
					ENDFOR				
				ENDIF				
				IF(visited node's X and Y = goal node's X and Y) THEN
				Return that solveIT method needs to be run with the necessary parameters				
				ENDIF				
			ENDIF		
		ENDFOR
	ENDWHILE	
	Return that No solution
ENDIF


AStarSearch()					
IF (intial position's X and Y = goal position's X and Y) THEN
Return that the solution is here and no need to move
ELSE
make frontier as a List
make visited as a List
make visitedNode as a point2D
ADD current position node to frontier
current position Gscore <- 0
	WHILE (anything is still in frontier)
	frontier <- ORDER elements in frontier BY Fscore and convert output TO LIST
	visitedNode <- FIRST element in frontier
	REMOVE the FIRST element from frontier	
	ADD visitedNode to visited 
	DRAW it using ui
		FOREACH(room r in map.room)
			IF(Visited node's X and Y = r's position's X and Y ) THEN
				IF(r has a path) THEN
					FOREACH(path p in r.path)
						IF(X and Y position noted in any of the nodes, in either visited or frontier, doesn't matches with that stated on the adjacent room attached on the other end of the p)	 THEN					
						ParentNode for the room located on the other side of the p <- visitedNode
						Gscore for the node for the room located on the other side of p <- visitedNode's Gscore + 1
						Fscore for the room located on the other side of the p <- squareroot of(sum of (square of difference between X value of room located on the other side of the p and goal) and (square of difference between Y value of room located on the other side of the p and goal))
						ADD the room located on the other side of path into the frontier						
						ENDIF
					ENDFOR				
				ENDIF				
				IF(visited node's X and Y = goal node's X and Y) THEN
				Return that solveIT method needs to be run with the necessary parameters				
				ENDIF				
			ENDIF		
		ENDFOR
	ENDWHILE	
	Return that No solution
ENDIF

	

AStarLimitedSearch()					
maxdepth <- map's length * height /2
depth <- max depth
IF (intial position's X and Y = goal position's X and Y and depth greater than 0) THEN
Return that the solution is here and no need to move
ELSE
make frontier as a List
make visited as a List
make visitedNode as a point2D
ADD current position node to frontier
current position Gscore <- 0
	WHILE (anything is still in frontier and depth greater than 0)
	frontier <- ORDER elements in frontier BY Fscore and convert output TO LIST
	visitedNode <- FIRST element in frontier
	REMOVE the FIRST element from frontier	
	ADD visitedNode to visited 
	DRAW it using ui
	depth <- depth - 1
		FOREACH(room r in map.room)
			IF(Visited node's X and Y = r's position's X and Y ) THEN
				IF(r has a path) THEN
					FOREACH(path p in r.path)
						IF(X and Y position noted in any of the nodes, in either visited or frontier, doesn't matches with that stated on the adjacent room attached on the other end of the p)	 THEN					
						ParentNode for the room located on the other side of the p <- visitedNode
						Gscore for the node for the room located on the other side of p <- visitedNode's Gscore + 1
						Fscore for the room located on the other side of the p <- squareroot of(sum of (square of difference between X value of room located on the other side of the p and goal) and (square of difference between Y value of room located on the other side of the p and goal))
						ADD the room located on the other side of path into the frontier						
						ENDIF
					ENDFOR				
				ENDIF				
				IF(visited node's X and Y = goal node's X and Y and depth greater than 0) THEN
				Return that solveIT method needs to be run with the necessary parameters				
				ENDIF				
			ENDIF		
		ENDFOR
	ENDWHILE	
	Return that No solution at given max depth
ENDIF





SolveIt(algorithm as method, intial position, current goal position as child node, list of nodes to solution as expanded)
Make new solution string
Make new path list
Make a new action list
REVERSE the expanded path
FOREACH(point2D p in expanded path)
	IF(p's X and Y = goal's X and Y) THEN
	ADD p to path list
	ENDIF
	IF(anything is inside path) THEN
		IF(X and Y of the ParentNode of the LAST element in path = X and Y of p) THEN
		ADD p to path list
		ENDIF	
	ENDIF	
ENDFOR
REVERSE the path list
FOR(i = 0 to total number of elements in path list)
	IF(i = total number of elements in path list - 1 )THEN
	BREAK	
	ENDIF
	IF(next element in path's Y value = current element in path's Y value - 1 )THEN
	ADD MOVEUP() to action list
	ENDIF
	IF(next element in path's X value = current element in path's X value - 1 )THEN
	ADD MOVELEFT() to action list
	ENDIF
	IF(next element in path's Y value = current element in path's Y value + 1 )THEN
	ADD MOVEDOWN() to action list
	ENDIF
	IF(next element in path's Y value = current element in path's Y value + 1 )THEN
	ADD MOVEDOWN() to action list
	ENDIF
ENDFOR
FOREACH(string a in action list)
solution <- solution + a + "; "
ENDFOR
DRAWPATH using ui and necessary parameters	
Return that method, no. of elements in expanded path and the solution 


A bug is an unexpected problem with software or hardware. Typical problems are often the result of external interference with the program’s performance that was not anticipated by the developer. 

a bug is basically an unexpected problem that arise when an external software interferes with the program being observed in such a way that wasn't forseen by the programmer
https://www.gartner.com/en/information-technology/glossary/bug

are usually results of an external interferance with


In case of blind search (DFS and DFSLimited), there had been significant difference in both the average time taken to run the limited algorithm to find the goal and also in average number of nodes searched. But average memory used and average path length of solution was almost similiar

In case of Heuristic Search (AStar abd AStarLimited), there has been almost no significant difference between them for the matrics.

Hence, considering the fact that limiting depth has the inherent disadvantage of not being able to find the goal (due to depth limit being reached before geeting to goal), it can be concluded that setting the limit is actually more disadvantagous, especially for Heuristic searches. Thus it would be better to run them without any depth limit

Note: All of these had been done for 5v5, 10v10 and 20v20 map sizes and different outcomes may be possible for larger maps. Furthermore, currently the depth limit had been set to (Maplength * MapHeight)/2 and thus it is also possible that a more optimum depth limit could provide better statistics  (i.e. finding goal more often whilst using lesser resources ) than its non-limited counterpart.

it doesn't provide  



In this program, a GUI had been implemented using the ui class which would draw the current position of agent, goal position, wall position, empty rooms, rooms that are in the frontier and the rooms that are currently being visited . Furthermore, it also details the node being present in its frontier, and also the node that is currently being visited (ie the one that is being expanded) in text below in a verbose manner (whilst algorithm is processing). 
Moveover, once the solution is found, it would also output the solution path in the diagram (linking initial to goal position) and also say the actiosn it took to reach the goal in a verbose manner  

and also the solution path(once it is found)



In this program, multigoal aspect has been programmed in the following manner: 
When the program goes through the file and notices that it has multiple goals (ie notices the occurance of " | " in the line), it automatically create multiple instances of the goal and pass them to the agent one by one. Then it asks the agent to first find the solution from its own position to one of the goal position, and then repeat the process for the 2nd goal position, and so on.

Thus, in the diagram produced by the UI class, it will always display only 1 intial and only 1 goal position (with the solution path linking them) and in order to see for the alternative goal position the user needs to press Enter (as adviced the program once the solution path to first goal has been displayed) which would display for initial position and the alternative goal



In order to gather necessary data for matrics mentoned in search algorithm section, an automatic data generation and collection method had been required. In order to accomplish this, a seperate program had been created called TestMapMaker (which would be used to make valid map files), a list of scripts had been created(to automatically run algorithms on the maps through command line) and some modifications had been made in the program itself (these have been commented out following the format displayed in ....FIG.....1?.....). These would cause it to create relevant files to store the required data, which would then be exported to a Microsoft Excelsheet (using technique discussed in ....REF.....) in order to organise the data and create the charts displayed in the search algorithm section

(insert picture of the commenting style to segment out the test case related stuff)
FIG...1?....commenting style used to segment automation commands




Missing feature basically means noting down if a required feature had not been implemented. In this case, the feature of enforcing the algorithms to perform their search in the order of Up, Left, Down and Right had not been properly implemented. Initially, it had been assumed that by setting up the path creation between rooms to occur in a certain way, it would cause the search algorithms to insert to the nodes to the frontier following that way as well. Unfortunately, that was only applicable for the BFS algorithm's case which used Queue type collection (stored data in first in first out manner) and not for the other algorithms which used STACK or LIST type collection. Instead, it would have been better to modify all the algorithms so that they would personally check the adjacent nodes and pass them in the order of Up, Left, Right, Down before passing them in the frontier. 

Note: This could be done by modifying the code after the repeated state check (still inside the "foreach (Path p in r.Paths)" loop for all the algorithms) so that it checked the path's location's (ie the room on the other side of the path) position's X and Y and order it so that room at top (Current node' X and Current node's Y-1 position) is inserted first, then left(Current node' X-1 and Current node's Y position), then bottom(Current node' X and Current node's Y +1 position) and finally right(Current node' X+1 and Current node's Y position).


....................

Go Brief into the research section and focus on the stuff (UI stuff + Test case geenration ---need pseudocode for test case geenration thingy)..... Max finish within the page 11


In terms of research, the following two ideas had been applied to the search program:
1)	GUI aspect design:
This had been done in order to ensure that the user will have a visual on how the algorithm is searching through the rooms to find the goal position and creating the path. In order to to do this, the program has been designed so that the Agent calls the Draw function each and everytime it inserts a node from frontier to visited (ie each time it expands the node). Then the draw function works in the following manner described using pesudocodes:


(insert pseudocode for Draw)
...FIG1?......FigName


Draw(intial position, current goal position, list of walls, visited node position, mapwidth, maplength, frontier as STACK)
CLEAR the Console
wallDrawn <- false
FOR (i = 0 to mapWidth)
	FOR (j = 0 to mapLength)
		IF(initial's X and Y position match with j and i)THEN
		WRITE "|i" in Console
		CONTINUE		
		ENDIF
		IF(goals's X and Y position match with j and i)THEN
		WRITE "|g" in Console
		CONTINUE		
		ENDIF
		IF(visitedNode's X and Y position match with j and i)THEN
		WRITE "|x" in Console
		CONTINUE		
		ENDIF
		IF(Any Frontier Node's X and Y position match with j and i)THEN
		WRITE "|f" in Console
		CONTINUE		
		ENDIF
		FOREACH(room r in wall)
			IF(r's IsWall = true and r' X and Y position match with j and i)THEN
			WRITE "|w" in Console
			wallDrawn <- true
			BREAK
			ENDIF
			wallDrawn <- false
		ENDFOR
		IF(wallDrawn = false)THEN
		WRITE "| " in Console				
		ENDIF
		
	ENDFOR
	WRITELINE "|" in Console
ENDFOR
IF(visitedNode's X and Y = Goal's X and Y)THEN
WRITELINE in console as a new line that solution has been found with X having VisitedNode's X and Y having VisitedNode's Y value
ELSE
WRITELINE in console "Frontier node:"
	FOREACH(var f in frontier)
	WRITELINE in console f's X and Y coordinates tabbed away
	ENDFOR
WRITELINE in console that visitedNode's X and Y is the X and Y for the current node that is being expanded
ENDIF
SLEEP the THREAD for 100 milliseconds
CLEAR the Console













Note: Here the Draw function has been overloaded so that it can handle for STACK, QUEUE and LIST type collection (in order to accomodate for all the algorithm's frontier's collection types). But even so, they still follow the same logic as the one describes in the ...FIG1?....given above this paragraph


Furthermore, Once the goal has been found and solution path has been created, the agent will call the DrawPath function in order to draw the solution path from initial to goal position. This function works in the following manner described using pseudo codes:





DrawPath(intial position, current goal position, list of walls, mapwidth, maplength, path as a list of nodes)
CLEAR the Console
wallDrawn <- false
FOR (i = 0 to mapWidth)
	FOR (j = 0 to mapLength)
		IF(initial's X and Y position match with j and i)THEN
		WRITE "|i" in Console
		CONTINUE		
		ENDIF
		IF(goals's X and Y position match with j and i)THEN
		WRITE "|g" in Console
		CONTINUE		
		ENDIF
		IF(Any Path Node's X and Y position match with j and i)THEN
		WRITE "|x" in Console
		CONTINUE		
		ENDIF		
		FOREACH(room r in wall)
			IF(r's IsWall = true and r' X and Y position match with j and i)THEN
			WRITE "|w" in Console
			wallDrawn <- true
			BREAK
			ENDIF
			wallDrawn <- false
		ENDFOR
		IF(wallDrawn = false)THEN
		WRITE "| " in Console				
		ENDIF
		
	ENDFOR
	WRITELINE "|" in Console
ENDFOR
WRITELINE in Console


(insert pseudocode for DrawPath)
...FIG1?......FigName


Note: Do keep in mind the issue about buffer and Console.Clear() that arose for the GUI. It has been already discussed in the Bugs section in the Feature/Bugs/Missing section 


2)	Automatic test case generation and data collection:
This had been done in order to ensure that the necessary data (ie average time taken for algorithm to run, average memory used by the algorithm, average no of nodes searched by the algorithm and average path length of the solution) can be collected in a systematic manner to ensure accuracy and validity of the findings. This had been done using a 3 part process:

i)Creation of Map Files: This had been done by creating a program called TestMapMaker. Its class diagram is as follows:

(insert class diagram)
...FIG1?......FigName



Its internal functions (ie logic behind map creation) can be explained using the Pseudocode provided below:


--make pseudocodes for all the functions




makeMultiWall(streamwriter, random no generator, maparraysize, startA as X position of start,startB as Y position of start) return a list of point2D
Make a new wallList 
Make a new tempwalllist
wallA <- random number from 0 to mapArray size
wallB <- random number from 0 to mapArray size
IF(mapArraySize is less than 2)THEN
mapArraySize <- 2
ENDIF
wallLength <- random number from 1 to mapArray size/2
wallWidth <- random number from 1 to mapArray size/2
finalwallA <- -1
finalwallB <- -1
finalwallLength <- -1
finalwallWidth <- -1
check <- false
FOR(j = wallB to wallB + walllength)
	FOR (k = wallA to wallA + wallWidth)
		If(k = starA and j = startB or K greater than mapArraySize or j greater than mapArraySize)THEN
		check <- true
		ENDIF
	ENDFOR
ENDFOR
IF(check = true)THEN
tempwalllist <- makeMultiWall with the necessary parameters
ENDIF
ELSE
finalwallA <- wallA
finalwallB <- wallB
finalwallLength <- wallLength
finalwallWidth <- wallWidth
Return wallList



makeGoals(streamwriter, random no generator, maparraysize, no of goals) return a list of point2D
Make a new goalist 
goalMakeRND <- no of goal
goalline <- ""
FOR(g = 0 to goalMakeRND)
	ADD new point2D (made using random number generator choosing from 0 to maparraysize) to goallist
	WRITELINE that goallist elements's X and Y value to console 
ENDFOR
FOR(gg = 0 to goalMakeRND)
	IF(gg = last element of goallist)THEN
	goalline <- goalline + "(X,Y)" where X and Y are that goallist's element's X and Y
	BREAK
	ELSE
	goalline <- goalline + "(X,Y) | " where X and Y are that goallist's element's X and Y
	ENDIF
ENDFOR
WRITELINE goalLine to the file
Return goallist


RemoveWallOnGoal( temporary wall list, goal list)
FOREACH(point2D wall in temporary wall list as a LIST())
	FOREACH(point2D goal in goal list)
		FOR(j = wallB to wallB + walllength)
			FOR (k = wallA to wallA + wallWidth)
				IF(k and j match with any of the goal's X and Y)THEN
				REMOVE wall from temporary wall list
				ENDIF
			ENDFOR
		ENDFOR
	ENDFOR
ENDFOR
Return temporary wall list



Main(args)
Run the Garbage collector
FOR(i = 0 to 100)
	myfile <- the path where you want to inject the map files to + Map[i].txt
	USING(Append the Text to the file using Streamwriter sw )
		mapArraySize <- size of the map's length and width, currently setting it as 20
		maxA <- mapArraySize
		maxB <- mapArraySize
		WRITELINE to file using sw "[maxA,MaxB]" where maxA and B are map's max width and length
		Make a new Random number generator rnd
		startA <- rnd from 0 to mapArraySize
		startB <- rnd from 0 to mapArraySize
		WRITELINE to file using sw "(startA,startB)" where startA and B are initial X and Y position
		finalGoalList <- makeGoals with necessary parameters
		temporaryWallList <- makeMultiWall with necessary parameters
		finalWallList <- RemoveWallOnGoal with necessary parameters
		FOREACH(point2D wall in finalWallList)
			WRITELINE to file using sw "(wall.X,wall.Y,wall.width,wall.length)" 
		ENDFOR
	ENDUSING
ENDFOR











wallB <- random number from 0 to mapArray size
IF(mapArraySize is less than 2)THEN
mapArraySize <- 2
ENDIF
wallLength <- random number from 1 to mapArray size/2
wallWidth <- random number from 1 to mapArray size/2
finalwallA <- -1
finalwallB <- -1
finalwallLength <- -1
finalwallWidth <- -1
check <- false
FOR(j = wallB to wallB + walllength)
	FOR (k = wallA to wallA + wallWidth)
		If(k = starA and j = startB or K greater than mapArraySize or j greater than mapArraySize)THEN
		check <- true
		ENDIF
	ENDFOR
ENDFOR
IF(check = true)THEN
tempwalllist <- makeMultiWall with the necessary parameters
ENDIF
ELSE
finalwallA <- wallA
finalwallB <- wallB
finalwallLength <- wallLength
finalwallWidth <- wallWidth
Return wallList







Main()




















(insert pseudocode diagram)
...FIG1?......FigName

Note: ++mention that currently you had designed to check the goals strictly and remove any wall coord set (ie wallx,wally,wallwidht,walllenght set) is any of the cords present there matches with goal.SO if you want to generate impossible goals…just comment the line: “      removewall on goal”

Alternative solution….use recursion to load the walls again and check with goal cords again…but lack of time and thus wasn’t able to set that up…possible future exploration

Problem if that it doesn’t try to generate again  

ii)After the maps have been created and placed in the same directory as the search file, Scripts are run from the command line. These have been made using the help of (REF1........for get-childitem......  and REF2...$_.BaseName......) and looks like this:

get-childitem Map*.txt | foreach-object{.\search.exe $_.BaseName gbfs}
(put that as a figure)
...FIG1?......FigName

In the  ..FIG1?.. +the above figure... the "get-childitem Map*.txt" is basically finding...____________......Then it is piping the results to run a foreach loop where its basically running the following command for all the map files found: ".\search.exe" "map file name" "gbfs"

iii)Once this is done, the search program runs and notes down:
	a) the number of ElapsedTicks taken by the algorithm to run, the totalMemoryUsed by asking GC (Garbage Collector) and the number of nodes that have been searched by asking ai's Visited list for its count. These are then stored into file called TestdataForAlgo[x].txt where x will be name of the search algorithm
	
	b)the optimal path by asking inside the agent's solveit method to tell the path count and storing it in the file called OptimalPathdata20v20[x].txt where x will be name of the search algorithm.
	
	Note: This can be further improved by passing all these data into the same file for a specific algorithm and mapsize and making the name more dynamic (ie TestDataForAlgo[mapLength]v[mapWidth][searchName]).
	
iv) After this, the data are passed to an excel sheet and an average is taken (depending on the algorithms used and the map sizes) before using those values to create the graphs. This has been done to ensure that the data obtained for each algorithm isn't impacted by any random error or any specific structure of any of the produced maps.


..............................................................



..............................................................
any specific structure of the map produced....




+say why you did it…how you did it (pseudo code)….details about output
+mention the factthat
++say which files you used to make automatic maps ++ the issue with that
++Scripts you had to pass to command line so that search can read multiple search maps back to map for automation
++Here say that you have GUI aspects ---fro easier visualization of what was happening--- also refer to previously put in pseudocode---

++say about how you generated testcases…. Say with pseudocodes and –say that you made for any number of goals 
++mention that currently you had designed to check the goals strictly and remove any wall coord set (ie wallx,wally,wallwidht,walllenght set) is any of the cords present there matches with goal.SO if you want to generate impossible goals…just comment the line: “      removewall on goal”

Alternative solution….use recursion to load the walls again and check with goal cords again…but lack of time and thus wasn’t able to set that up…possible future exploration

Problem if that it doesn’t try to generate again  



Overall it has been seen that (in terms of the matrics noted in Search Algorithm Section) for small maps (ie 5v5) A Star and A Star Limited had the best perfromance whilst for big maps (10v10 and 20v20) GDBF had best performance. 

Furthermore, comparing the custom algorithms with thier non-depth-limited counterparts showed that setting the depth-limit doesnt actually provide much advatage in performance compared to its tradeoff in reduction in chance of reaching the goal. But it does provide a bigger impact on blind algorithms case than in heuristic algorithms case.

But, even so, it can't be concluded that GBFS algorithm will be the best choice for any large maps (as it has only been tested for those 3 mapsizes and not for bigger maps like 100v100) or that setting of depth-limit is disadvantageous (as it has not been tested for all possible depth-limits and so it's possible that the depth-limit used here isn't the optimal one). 

Hence, it will be better to repeat this experiment in the future with bigger map sizes (to test for all algorithms) and also test for varying depth sizes (on those maps) for the custom algorithms

Note: It will be better to create the future program using a different programming language and editor. Thats because for C# code it's extremely difficult to convert the codes into a single .exe format (so much so that if you use the wrong project setup in the beginning, like me, then you will have to redo the entire project again....REF.....). This not only limits the developers from using any of good UIs (unless you also put in dlls with .exe file) and rely on a crude self-made one, but also discourages them from adding extra facilities to the program (i.e creating a new program to make the Mapfile instead of bundling it as part of the search program file ). Instead, it would be better to use Python and use.....(REF)>... to convert it to .exe directly

……speak about data from standard and custom ones…. Which one won…. Depth limit benefit or harmful….
NOTE: +++had been difficult to make GUI without using any external libraries…..difficulty in converting to .exe…and thus having to recreate the program from scratch several times as  …hence even created testmap generator as separate program to prevent visual studio from bugging out the build to current one

++say future experiements should be done with bigger maps built on different editor using different language as it would be easier to both convert to .exe and also continuing modifying it without it glitching out
++say that you did with small map size 5v5 10v10 20v20..but could have also tried with 100v100 and thus can’t say for certain about big sizes



Fig-7 to

last figure no
Fig-22: smth

Graph-5:....(do with underline from g to :)



pg 12....small concluion and achknoeledgements + reference using IEEE 

Software Feature Wikipedia page in accurately defining software features,

Gartner's Information Technology Glossary's Bug page in providing me the definition for bug,

TRCCompSci's wikipedia for providing the syntax for writing pseudocode,

Hui's book on Robot systems for Rail Transit Application and Anis and Ahmad's book on Unmanned Aerial Systems in accurately portraying the importance of Robot Navigation in Robotics,

Cheng's Paper on Research on Path Planning of Robot Based on Artificial Intelligence Algorithm in accurately portraying the importance of Robot Navigation in AI,

Sriniketh's blog on Uninformed Search Algorithms: Exploring New Possibilities (Updated 2023) in pointing out the benefits and drawbacks of a depth limited Search (ie DFS Limited),

TutorialsTeacher's C# collection's Stack page for providing me the understandings I needed to use properly use the STACK type collection in my program,

TutorialsTeacher's C# collection's Queue page for providing me the understandings I needed to use properly use the QUEUE type collection in my program,


Microsoft's .NET documentation on Console.Clear() command in helping me understand where and how to use it

Microsoft's .NET documentation on Single-file deployment in helping me understand that I had set up the wrong project and that I would need to recreate the project in .NET Framework to ensure that only a single .exe file will be produced

Microsoft's Powershell documentation on Get-ChildItem command in helping me understand where and how to use it

Microsoft's Powershell documentation about_Automatic_Variables's $this section's BaseName example in helping me get the idea on where and how I can use it


Microsoft's Support documentation on how to transfer data from a delimited text file to an Excel sheet

GeeksForGeeks' Convert Python Script to .exe File's page in providing me with a simple step-by-step walkthough on how python codes could easily be converted into .exe


[1] Wikipedia Contributors, “Robot navigation,” Wikipedia, Mar. 13, 2019. https://en.wikipedia.org/wiki/Robot_navigation








https://www.sciencedirect.com/book/9780128229682/robot-systems-for-rail-transit-applications, ---use of robot navigation in rail transport system -- to show importance of Robot navigation in robotics
 https://www.sciencedirect.com/book/9780128202760/unmanned-aerial-systems ---use of robot navigation in unmanned aerial system -- to show importance of Robot navigation in robotics
 
 Anis Koubaa and Ahmad Taher Azar
 
https://iopscience.iop.org/article/10.1088/1742-6596/1544/1/012032/pdf#:~:text=Abstract.,Goal%20of%20Maximizing%20the%20Return. --- Research on Path Planning of Robot Based on
Artificial Intelligence Algorithm--- to show importance of Robot navigation in AI

Academic/Lecturer(s) Initial(s). Surname(s). (Year). Title of workshop/lecture [Type of Medium]. Available: URL 

B. Vo. (2023) Introduction [Powerpoint Slide]. Available: https://swinburne.instructure.com/courses/49155/pages/w1-learning-materials-lectures-+-reading?module_item_id=3357404

BAO VO Slide for rational stuff (week 1 and 2 ig)---definition of rational agent (it came up 2 times)



(REF Lecture slide 31 from week 3) ----defn of blind and heuristic algorithms (came up 2 times)


Bo Li Assignment 1 sheet --- helped ceate and organise the entire report

https://www.analyticsvidhya.com/blog/2021/02/uninformed-search-algorithms-in-ai/ ---- benefit of having depth limit on algorithms using POV of uninformed (ie blind) search......

https://www.trccompsci.online/mediawiki/index.php/CSharp_to_Pseudo_Code ---for pseudocode syntax

https://www.tutorialsteacher.com/csharp/csharp-stack ---to know about STACK
https://www.tutorialsteacher.com/csharp/csharp-queue ---to know about Queue
https://www.gartner.com/en/information-technology/glossary/bug ---for bug definition

https://learn.microsoft.com/en-us/dotnet/api/system.console.clear?view=net-5.0 ---for documneation on Console.Clear() command

https://en.wikipedia.org/wiki/Software_feature  ---for definition of software feature

https://support.microsoft.com/en-us/office/import-or-export-text-txt-or-csv-files-5250ac4c-663c-47ce-937b-339e391393ba ---for explaining process to convert data from txt to excel sheet





https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-childitem?view=powershell-7.3 --- for explaining Get-ChildItem and how to use it

https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables?view=powershell-7.3 ---for explaining BaseName and how to use it

https://learn.microsoft.com/en-us/dotnet/core/deploying/?WT.mc_id=DT-MVP-5002999 ---ensure to deploy in right project type and how to convert to .exe

https://www.geeksforgeeks.org/convert-python-script-to-exe-file/ --- walkthourhg for converting pythong code to .exe




++ Clean up code  __both for search one ++ also for debug and other stguff to allow for clean submission!!
(CLEAN INSIDE THE FOLDERS FOR VERSION 3)

++submit it by today!